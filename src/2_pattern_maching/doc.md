# パターンマッチ

- パターンマッチで変数に値を束縛する方法
- 構造化されたデータの取り扱い方法
- \_でマッチを無視する方法

## 代入

elixir では `=` は代入ではない。表明に近い。

```ex
a = 1
1 = a
> 1
2 = a
>MatchingError
```

elixir は左辺の変数の値しか変更しない。
右辺にある変数についてはすでに設定されたそれ自身の値を置き換えることしかしない。

## リスト

elixir のリストは[]で表し、型の違う要素も格納できる。

```ex
list = [1,2,3]
[a,b,c] = list
a
> 1
```

elixir は左辺の値と右辺の値を同じにする方法を探す。

\_スコアでセットされた変数を即座に破棄する。

```ex
[1,_,_] = [1,2,3]
```

マッチの過程の途中で一度変数がある値に束縛されると変数はその値を以降のマッチの処理中ずっと保持する

```ex
[a,a] = [1,1]
a
> 1

[b,b] = [1,2]
> MatchError
```

下の例は最初のマッチで b に１を束縛したのに 2 を新たに束縛させることはできない。

違うマッチングであれば大丈夫

```ex
a = 1
[a,3,5] = [2,3,5]
```

現在の値をパターンの中で使わせたい場合は^を使う
ピン演算子と呼ぶ

```ex
a = 1
[^a,2,3] = [1,2,3]
[^a,3] = [2,3]
> MatchError
```

elixir の=は代入ではない。左辺と右辺が等しいという表明になる。変数は左辺にある時だけ代入することができる
